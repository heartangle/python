# 面向对象编程基础

"""
活在当下的程序员应该都听过“面向对象编程”一词，也经常有人问能不能用一句话解释下什么是
“面向对象编程”，我们来看比较正式的说法。
	把一组数据和处理他们的方法组成对象，把相同行为的对象归纳为类，通过类的封装，隐藏
	内部细节，通过继承实现类的特化和泛化，通过多态实现基于对象类型的动态分配。
————————————————————————————————————————————————————————————————————————
	封装：不管你是土鳖还是土豪，不管你中午吃的是窝头还是鲍鱼，你的下水都在你的肚皮里，别
人看不到你中午吃了啥，除非你自己说给他们听(或者画给他们看)
	继承：刚说了，你个土鳖/豪，你们全家都是土豪/鳖。冰冻三尺非一日之寒，你有今天，必定可以
从你爸爸爷爷那里追根溯源。正所谓虎父无犬子，正恩同学那么狠，他爹正日就不是什么善茬，更甭说
他爷爷。
多态：哲学家说过，世上不会有两个一模一样的双胞胎。及及时你从你父亲那里继承来的土鳖/土豪气质
也完全不可能是从一个模子里刻出来的，总会有些差别。比如你爸爸喜欢蹲在门前面吃面，你喜欢骑
在村口的歪脖子树上吃，或者反过来。当然，也可能令尊喜欢吃鲍鱼时旁边有几个艺校小女生喝酒
唱歌助兴，你可能喜欢弄个街舞乐队来吹拉弹唱。
————————————————————————————————————————————————————————————————————————

之前我们说过“程序是指令的集合”，我们在程序中书写的语句在执行时会变成一条或多条指令然后由
CPU去执行。当然为了简化程序的设计，我们引入了函数的概念，把相对独立且经常重复使用的代码
放置到函数中，在需要使用这些功能的时候只要调用函数即可；如果一个函数的功能过于复杂和臃肿
我们又可以进一步将函数继续切分为子函数来降低系统的复杂性。但是说了这么多，不知道大家
是否发现，所谓编程就是程序员按照计算机的工作方式控制计算机完成各种任务。但是，计算机的
工作方式与正常人类的思维模式是不同的，如果编程就必须得抛弃人类正常的思维方式去迎合计算机
编程的乐趣就少了很多，“每个人都应该学习编程”这样的豪言壮语就只能说说而已。当然，这些还不
是最重要的，最重要的是当我们需要开发一个复杂的系统时，代码的复杂性会让开发和维护工作都变
得举步维艰，所以在上世纪60年代末期，“软件危机”、“软件工程”等一系列的概念开始在行业中出现。

当然，程序员圈子内的人都知道，现实中并没有解决上面所说的这些问题的“银弹”，真正让软件
开发者看到希望的是上世纪70年代诞生的Smalltalk编程语言中引入的面向对象的编程思想
（面向对象编程的雏形可以追溯到更早期的Simula语言）。按照这种编程理念，
程序中的数据和操作数据的函数是一个逻辑上的整体，我们称之为“对象”，而我们解决问题的方式
就是创建出需要的对象并向对象发出各种各样的消息，多个对象的协同工作最终可以让我们构造出
复杂的系统来解决现实中的问题。

说明： 当然面向对象也不是解决软件开发中所有问题的最后的“银弹”，所以今天的高级程序
设计语言几乎都提供了对多种编程范式的支持，Python也不例外。
———————————————————————————————————————————————————————————————————————
"""

# 类和对象
"""
简单的说，类是对象的蓝图和模板，而对象是类的实例。从这句话我们可以看出，类是抽象的概念
而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象
都是独一无二的，而且对象是独一无二的，而且对象一定属于某个类(型)。当我们把一大堆拥有共同
特征的对象的静态特征(属性)和动态特征(行为)都抽取出来，就可以定义出一个叫做"类的东西"。
"""

# 定义类
'''
"""
在python中使用 class 关键字定义类，然后在类中通过函数来定义方法，这样就可以将对象的
动态特征描述出来。
"""

class Student(object):
	# __init__是一个特殊方法用于在创建对象时进行初始化操作
	# 通过这个方法我们可以为学生对象绑定nam和age两个属性
	def __init__(self,name,age):
		self.name = name
		self.age = age
	def study(self,course_name):
		print('%s正在学习%s.'%(self.name, course_name))
	# PEP 8要求标识符的名字用全小写，多个单词时下划线连接
	# 但是很多程序员和公司更倾向与使用驼峰命名法
	def watch_av(self):
		if self.age < 18:
			print('%s只能观看《熊出没》.' % self.name)
		else:
			print('%s正在观看到岛国爱情片.' % self.name)
# 说明：写在类中的函数，我们通常称之为(对象的方法),这些方法就是对象可以接受到的消息
'''
# 创建和使用对象
'''
def main():
	# 创建学生对象并且指定姓名和年龄
	stu1 = Student('王朝阳',22)
	# 给对象发study消息
	stu1.study('python程序设计')
	# 给对象发watch_av消息
	stu1.watch_av()
	stu2 = Student('王大锤',15)
	stu2.study('思想品德')
	stu2.watch_av()
main()
'''

# 访问可见性的问题
'''
"""
对于上面的代码，有C++、Java、C#等编程经验的程序员可能会问，我们给Student对象绑定
的name和age属性到底具有怎样的访问权限（也称为可见性）。因为在很多面向对象编程语言中，
我们通常会将对象的属性设置为私有的（private）或受保护的（protected），
简单的说就是不允许外界访问，而对象的方法通常都是公开的（public），因为公开的方法就是
对象能够接受的消息。在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，
如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头，下面的代码可以验证这一点。
"""
class Test:
	def __init__(self,foo):
		self.__foo = foo
	def __bar(self):
		print(self.__foo)
		print('__bar')

def main():
	test = Test('hello')
	test.__bar() # AttributeError: 'Test' object has no attribute '__bar'
	print(test.__foo) # AttributeError: 'Test' object has no attribute '__foo'
main()
'''

"""
但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了
一个名字来“妨碍”对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，
下面的代码就可以验证这一点。之所以这样设定，可以用这样一句名言加以解释，
就是“We are all consenting adults here”。因为绝大多数程序员都认为开放比封闭要好，
而且程序员要自己为自己的行为负责。
"""

"""
class Test:
	def __init__(self,foo):
		self.__foo = foo
	def __bar(self):
		print(self.__foo)
		print('__bar')
def main():
	test = Test('hello')
	test._Test__bar()
	print(test._Test__foo)
main()
"""

"""
在实际开发中，我们并不建议将属性设置为私有的，因为这样会导致子类无法访问。所以大多数python
程序员会遵循一种命名习惯就是让属性以单下划线开头来表示属性是受保护的，本类之外的代码在
访问这样的属性时应该保持慎重。这种做法不是语法上的规则，单下划线的属性和方法外界仍然是可以
访问的，所以更多的时候它是一种暗示。
"""

# 面向对象的支柱
"""
面向对象有三大支柱：封装，继承和多态。我自己对封装的理解是“隐藏一切可以隐藏的实现细节，
只向外界暴露（提供）简单的编程接口”。我们在类中定义的方法其实就是把数据和对数据的
操作封装起来了，在我们创建了对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法
中的代码，也就是说我们只需要知道方法的名字和传入的参数（方法的外部视图），而不需要知道
方法内部的实现细节（方法的内部视图）。
"""
"""——————————————————————————————————————————————————————————————————"""

# 练习1：定义一个类描述数字时钟
'''
import time
import os
class Clock(object):
	"""数字时钟"""
	def __init__(self,hour=0,minute=0,second=0):
		"""初始化方法
		:param hour:时
		:param minute：分
		:param second: 秒
		"""
		self._hour = hour
		self._minute = minute
		self._second = second
	def run(self):
		"""走字"""
		self._second += 1
		if self._second == 60:
			self.second = 0
			self._minute += 1
			if self._minute == 60:
				self.minute = 0
				self._hour += 1
				if self._hour == 24:
					self._hour = 0
	def show(self):
		"""显示时间"""
		return '%02d:%02d:%02d' % (self._hour,self._minute,self._second)

def main():
	clock = Clock(23,58,00)
	while True:
		print(clock.show())
		time.sleep(1)
		clock.run()
main()
'''

# 练习2：定义一个类描述平面上的并提供移动点和计算到另外一个点的距离的方法
'''
from math import sqrt
class Point(object):
	def __init__(self,x=0,y=0):
		"""初始化方法
		:param x: 横坐标
		:param y: 纵坐标
		"""
		self.x = x
		self.y = y
	def move_to(self,x,y):
		"""移动到指定位置
		:param x: 新的横坐标
		:param x: 新的纵坐标
		"""
		self.x = x
		self.y = y
	def move_by(self,dx,dy):
		"""移动到指定增量
		:param dx: 横坐标的增量
		:param dy: 纵坐标的增量
		"""
		self.x += dx
		self.y += dy
	def distance_to(self,other):
		"""计算与另外一个点的距离
		:param otner: 另一个点
		"""
		dx = self.x - other.x
		dy = self.y - other.y
		return sqrt(dx**2 + dy**2)
	def __str__(self):
		return '(%s,%s)' % (str(self.x),str(self.y))
def main():
	p1 = Point(3,5)
	p2 = Point()
	print(p1)
	print(p2)
	p2.move_by(-1,2)
	print(p2)
	print(p1.distance_to(p2))
main()
'''
